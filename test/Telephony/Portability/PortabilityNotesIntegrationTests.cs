using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using Sufficit.Client;
using Sufficit.EndPoints;
using Sufficit.EndPoints.Configuration;
using Sufficit.Identity;
using Sufficit.Telephony.Portability;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;

namespace Sufficit.Client.IntegrationTests.Telephony.Portability
{
    /// <summary>
    /// Integration tests for Portability Notes System (Manager role only)
    /// Tests CRUD operations, security filters, and CASCADE DELETE behavior
    /// 
    /// Configuration in appsettings.json:
    /// - Sufficit:EndPoints:BaseAddress - API base URL
    /// - Sufficit:Authentication:Tokens:Manager - Manager token for authentication
    /// - Sufficit:TestData:Telephony:Portability:KnownPortabilityId - Test portability process ID
    /// </summary>
    [Trait("Category", "Integration")]
    public class PortabilityNotesIntegrationTests : IDisposable
    {
        private readonly ITestOutputHelper _output;
        private readonly APIClientService _authenticatedClient;
        private readonly Guid _testPortabilityId;

        public PortabilityNotesIntegrationTests(ITestOutputHelper output)
        {
            _output = output;

            // Load configuration from appsettings.json
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: false)
                .AddEnvironmentVariables()
                .Build();

            var endpointsUrl = configuration["Sufficit:EndPoints:BaseAddress"]
                ?? throw new InvalidOperationException("EndPoints BaseAddress not configured in appsettings.json");

            var token = configuration["Sufficit:Authentication:Tokens:Manager"]
                ?? throw new InvalidOperationException("Manager token not configured in appsettings.json");

            var testId = configuration["Sufficit:TestData:Telephony:Portability:KnownPortabilityId"]
                ?? throw new InvalidOperationException("TestData Telephony Portability KnownPortabilityId not configured in appsettings.json");

            _testPortabilityId = Guid.Parse(testId);

            var timeout = uint.TryParse(configuration["Sufficit:EndPoints:TimeOut"], out var t) ? t : 30u;

            // Configure EndPoints options
            var options = new EndPointsAPIOptions
            {
                BaseAddress = endpointsUrl,
                TimeOut = timeout
            };

            // Create authenticated API client (Manager role)
            _authenticatedClient = new APIClientService(
                Options.Create(options),
                new StaticTokenProvider(token),
                NullLogger<APIClientService>.Instance);

            _output.WriteLine($"[SETUP] Base URL: {endpointsUrl}");
            _output.WriteLine($"[SETUP] Test Portability ID: {_testPortabilityId}");
        }

        public void Dispose()
        {
            // Cleanup if needed
        }

        /// <summary>
        /// Test 1: Add note with current timestamp (auto-generated by server)
        /// </summary>
        [Fact]
        [Trait("Order", "1")]
        public async Task AddNote_WithCurrentTimestamp_ShouldSucceed()
        {
            // Arrange
            var text = $"Test note created at {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC";
            _output.WriteLine($"[TEST 1] Adding note: {text}");

            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = true
                // Timestamp not set - will be auto-generated by server
            };

            // Act
            var result = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            // Assert
            Assert.Equal(1, result); // Should return 1 (affected rows)

            // Verify note was created by fetching it
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId,
                @public: true,
                CancellationToken.None);

            var createdNote = notes.FirstOrDefault(n => n.Text == text);
            Assert.NotNull(createdNote);
            Assert.Equal(_testPortabilityId, createdNote.ProcessId);
            Assert.Equal(text, createdNote.Text);
            Assert.True(createdNote.Public);
            Assert.True((DateTime.UtcNow - createdNote.Timestamp).TotalMinutes < 1);

            _output.WriteLine($"[TEST 1] ✅ Note created: {createdNote.Text}");
        }

        /// <summary>
        /// Test 2: Add note with custom timestamp (retroactive note)
        /// </summary>
        [Fact]
        [Trait("Order", "2")]
        public async Task AddNote_WithCustomTimestamp_ShouldUseProvidedTimestamp()
        {
            // Arrange
            var customTimestamp = new DateTime(2024, 1, 15, 14, 30, 0, DateTimeKind.Utc);
            var text = "Retroactive note from January 2024";
            _output.WriteLine($"[TEST 2] Adding retroactive note with timestamp: {customTimestamp:yyyy-MM-dd HH:mm:ss}");

            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = false,
                Timestamp = customTimestamp
            };

            // Act
            var result = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            // Assert
            Assert.Equal(1, result); // Should return 1 (affected rows)

            // Verify note was created with correct timestamp
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId,
                @public: null, // Manager can see private notes
                CancellationToken.None);

            var createdNote = notes.FirstOrDefault(n => n.Timestamp == customTimestamp);
            Assert.NotNull(createdNote);
            Assert.Equal(_testPortabilityId, createdNote.ProcessId);
            Assert.Equal(text, createdNote.Text);
            Assert.False(createdNote.Public);
            Assert.Equal(customTimestamp, createdNote.Timestamp);

            _output.WriteLine($"[TEST 2] ✅ Retroactive note created: {createdNote.Timestamp:yyyy-MM-dd HH:mm:ss}");
        }

        /// <summary>
        /// Test 3: GetNotes as Manager without public filter (should return all notes)
        /// </summary>
        [Fact]
        [Trait("Order", "3")]
        public async Task GetNotes_AsManager_ShouldReturnAllNotes()
        {
            // Arrange
            _output.WriteLine("[TEST 3] Getting all notes as Manager (no filter)");

            // Act
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: null, 
                CancellationToken.None);

            // Assert
            Assert.NotNull(notes);
            Assert.NotEmpty(notes);

            var hasPublic = notes.Any(n => n.Public);
            var hasPrivate = notes.Any(n => !n.Public);
            Assert.True(hasPublic && hasPrivate, "Manager should see both public AND private notes");

            _output.WriteLine($"[TEST 3] ✅ Manager retrieved {notes.Count} notes (public: {notes.Count(n => n.Public)}, private: {notes.Count(n => !n.Public)})");
        }

        /// <summary>
        /// Test 4: GetNotes with public=true filter
        /// </summary>
        [Fact]
        [Trait("Order", "4")]
        public async Task GetNotes_WithPublicOnlyFilter_ShouldReturnOnlyPublicNotes()
        {
            // Arrange
            _output.WriteLine("[TEST 4] Getting notes with public=true filter");

            // Act
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: true, 
                CancellationToken.None);

            // Assert
            Assert.NotNull(notes);
            Assert.All(notes, n => Assert.True(n.Public, "All notes should be public when public=true"));

            _output.WriteLine($"[TEST 4] ✅ Retrieved {notes.Count} public notes");
        }

        /// <summary>
        /// Test 5: SECURITY TEST - Unauthenticated should only see public notes
        /// </summary>
        [Fact]
        [Trait("Order", "5")]
        [Trait("Category", "Security")]
        public async Task GetNotes_Unauthenticated_ShouldReturnOnlyPublicNotes()
        {
            // Arrange
            _output.WriteLine("[TEST 5] SECURITY TEST: Getting notes without authentication");

            // Create unauthenticated client (empty token)
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: false)
                .Build();

            var endpointsUrl = configuration["Sufficit:EndPoints:BaseAddress"]!;
            var timeout = uint.TryParse(configuration["Sufficit:EndPoints:TimeOut"], out var t) ? t : 30u;

            var options = new EndPointsAPIOptions
            {
                BaseAddress = endpointsUrl,
                TimeOut = timeout
            };

            var unauthenticatedClient = new APIClientService(
                Options.Create(options),
                new StaticTokenProvider(string.Empty), // Empty token = unauthenticated
                NullLogger<APIClientService>.Instance);

            // Act
            var notes = await unauthenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: null, // Don't specify - server should force public
                CancellationToken.None);

            // Assert
            Assert.NotNull(notes);
            Assert.All(notes, n => Assert.True(n.Public, "❌ SECURITY VIOLATION: Unauthenticated saw private notes!"));

            _output.WriteLine($"[TEST 5] ✅ SECURITY: Unauthenticated retrieved {notes.Count} notes (all public)");
        }

        /// <summary>
        /// Test 6: RemoveNote by timestamp (composite key: processId + timestamp)
        /// </summary>
        [Fact]
        [Trait("Order", "6")]
        public async Task RemoveNote_ByTimestamp_ShouldDeleteSpecificNote()
        {
            // Arrange - Create note with specific timestamp
            var specificTimestamp = new DateTime(2025, 1, 1, 12, 0, 0, DateTimeKind.Utc);
            var text = "Note to be deleted";
            _output.WriteLine($"[TEST 6] Creating note with timestamp {specificTimestamp:yyyy-MM-dd HH:mm:ss} for deletion");

            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = true,
                Timestamp = specificTimestamp
            };

            var createResult = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            Assert.Equal(1, createResult);
            _output.WriteLine($"[TEST 6] Note created successfully");

            // Act - Delete by timestamp
            var deleteResult = await _authenticatedClient.Telephony.Portability.RemoveNote(
                _testPortabilityId, 
                specificTimestamp, 
                CancellationToken.None);

            // Assert - Verify deletion
            Assert.Equal(1, deleteResult);
            _output.WriteLine($"[TEST 6] Delete operation returned: {deleteResult}");

            // Verify note no longer exists
            var allNotes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: null, 
                CancellationToken.None);

            Assert.DoesNotContain(allNotes, n => n.Timestamp == specificTimestamp);

            _output.WriteLine($"[TEST 6] ✅ Note deleted successfully");
        }

        /// <summary>
        /// Test 7: Validate empty text should fail
        /// </summary>
        [Fact]
        [Trait("Order", "7")]
        public async Task AddNote_WithEmptyText_ShouldFail()
        {
            // Arrange
            _output.WriteLine("[TEST 7] Testing empty text validation");

            // Act & Assert
            await Assert.ThrowsAnyAsync<Exception>(async () =>
            {
                var note = new PortabilityNote
                {
                    ProcessId = _testPortabilityId,
                    Text = string.Empty,
                    Public = true
                };

                await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                    note, 
                    CancellationToken.None);
            });

            _output.WriteLine($"[TEST 7] ✅ Empty text validation working");
        }

        /// <summary>
        /// Test 8: Future timestamp should be accepted (no timestamp restrictions)
        /// </summary>
        [Fact]
        [Trait("Order", "8")]
        public async Task AddNote_WithFutureTimestamp_ShouldSucceed()
        {
            // Arrange
            var futureTimestamp = DateTime.UtcNow.AddDays(30);
            var text = "Future note (scheduled)";
            _output.WriteLine($"[TEST 8] Adding note with future timestamp: {futureTimestamp:yyyy-MM-dd}");

            // Act
            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = true,
                Timestamp = futureTimestamp
            };

            var result = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            // Assert
            Assert.Equal(1, result);

            // Verify timestamp was used
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId,
                @public: true,
                CancellationToken.None);

            var createdNote = notes.FirstOrDefault(n => n.Timestamp == futureTimestamp);
            Assert.NotNull(createdNote);
            Assert.Equal(futureTimestamp, createdNote.Timestamp);

            // Cleanup
            await _authenticatedClient.Telephony.Portability.RemoveNote(
                _testPortabilityId, 
                futureTimestamp, 
                CancellationToken.None);

            _output.WriteLine($"[TEST 8] ✅ Future timestamp accepted: {futureTimestamp:yyyy-MM-dd}");
        }

        /// <summary>
        /// Test 9: Verify notes are ordered by timestamp descending (newest first)
        /// </summary>
        [Fact]
        [Trait("Order", "9")]
        public async Task GetNotes_OrderedByTimestamp_ShouldBeDescending()
        {
            // Arrange
            _output.WriteLine("[TEST 9] Verifying notes ordering (newest first)");

            // Act
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: null, 
                CancellationToken.None);

            // Assert
            Assert.NotNull(notes);
            Assert.NotEmpty(notes);

            // Verify descending order (most recent first)
            var timestamps = notes.Select(n => n.Timestamp).ToList();
            for (int i = 0; i < timestamps.Count - 1; i++)
            {
                Assert.True(timestamps[i] >= timestamps[i + 1], 
                    $"Notes not in descending order at index {i}");
            }

            _output.WriteLine($"[TEST 9] ✅ {notes.Count} notes correctly ordered (newest first)");
        }

        /// <summary>
        /// Test 10: Validate CASCADE DELETE - removing process should delete all notes
        /// MANUAL TEST - requires explicit execution
        /// </summary>
        [Fact(Skip = "Manual test - requires process creation/deletion")]
        [Trait("Order", "10")]
        [Trait("Category", "Manual")]
        public async Task RemoveProcess_ShouldCascadeDeleteAllNotes()
        {
            _output.WriteLine("[TEST 10] ⚠️ WARNING: This test creates and deletes data. Manual cleanup may be required.");
            
            // TODO: This test requires creating a new test process, adding notes, then deleting the process
            // Database CASCADE DELETE should automatically remove all notes
            
            await Task.CompletedTask;
        }
    }
}
