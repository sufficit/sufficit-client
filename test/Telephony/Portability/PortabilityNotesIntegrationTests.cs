using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using Sufficit.Client;
using Sufficit.EndPoints;
using Sufficit.EndPoints.Configuration;
using Sufficit.Identity;
using Sufficit.Telephony.Portability;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using Xunit.Abstractions;

namespace Sufficit.Client.IntegrationTests.Telephony.Portability
{
    /// <summary>
    /// Integration tests for Portability Notes System (Manager role only)
    /// Tests CRUD operations, security filters, and CASCADE DELETE behavior
    /// 
    /// Configuration in appsettings.json:
    /// - Sufficit:EndPoints:BaseAddress - API base URL
    /// - Sufficit:Authentication:Tokens:Manager - Manager token for authentication
    /// - Sufficit:TestData:Telephony:Portability:KnownPortabilityId - Test portability process ID
    /// </summary>
    [Trait("Category", "Integration")]
    public class PortabilityNotesIntegrationTests : IDisposable
    {
        private readonly ITestOutputHelper _output;
        private readonly APIClientService _authenticatedClient;
        private readonly Guid _testPortabilityId;

        public PortabilityNotesIntegrationTests(ITestOutputHelper output)
        {
            _output = output;

            // Load configuration from appsettings.json
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: false)
                .AddEnvironmentVariables()
                .Build();

            var endpointsUrl = configuration["Sufficit:EndPoints:BaseAddress"]
                ?? throw new InvalidOperationException("EndPoints BaseAddress not configured in appsettings.json");

            var token = configuration["Sufficit:Authentication:Tokens:Manager"]
                ?? throw new InvalidOperationException("Manager token not configured in appsettings.json");

            var testId = configuration["Sufficit:TestData:Telephony:Portability:KnownPortabilityId"]
                ?? throw new InvalidOperationException("TestData Telephony Portability KnownPortabilityId not configured in appsettings.json");

            _testPortabilityId = Guid.Parse(testId);

            var timeout = uint.TryParse(configuration["Sufficit:EndPoints:TimeOut"], out var t) ? t : 30u;

            // Configure EndPoints options
            var options = new EndPointsAPIOptions
            {
                BaseAddress = endpointsUrl,
                TimeOut = timeout
            };

            // Create authenticated API client (Manager role)
            _authenticatedClient = new APIClientService(
                Options.Create(options),
                new StaticTokenProvider(token),
                NullLogger<APIClientService>.Instance);

            _output.WriteLine($"[SETUP] Base URL: {endpointsUrl}");
            _output.WriteLine($"[SETUP] Test Portability ID: {_testPortabilityId}");
        }

        public void Dispose()
        {
            // Cleanup if needed
        }

        /// <summary>
        /// Test 1: Add note with current timestamp (auto-generated by server)
        /// </summary>
        [Fact]
        [Trait("Order", "1")]
        public async Task AddNote_WithCurrentTimestamp_ShouldSucceed()
        {
            // Arrange
            var text = $"Test note created at {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC";
            _output.WriteLine($"[TEST 1] Adding note: {text}");

            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = true
                // Timestamp not set - will be auto-generated by server
            };

            // Act
            var result = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            // Assert
            Assert.Equal(1, result); // Should return 1 (affected rows)

            // Verify note was created by fetching it
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId,
                @public: true,
                CancellationToken.None);

            var createdNote = notes.FirstOrDefault(n => n.Text == text);
            Assert.NotNull(createdNote);
            Assert.Equal(_testPortabilityId, createdNote.ProcessId);
            Assert.Equal(text, createdNote.Text);
            Assert.True(createdNote.Public);
            Assert.True((DateTime.UtcNow - createdNote.Timestamp).TotalMinutes < 1);

            _output.WriteLine($"[TEST 1] ✅ Note created: {createdNote.Text}");
        }

        /// <summary>
        /// Test 2: Add note with custom timestamp (retroactive note)
        /// </summary>
        [Fact]
        [Trait("Order", "2")]
        public async Task AddNote_WithCustomTimestamp_ShouldUseProvidedTimestamp()
        {
            // Arrange
            var customTimestamp = new DateTime(2024, 1, 15, 14, 30, 0, DateTimeKind.Utc);
            var text = $"Retroactive note from January 2024 {Guid.NewGuid():N}";
            _output.WriteLine($"[TEST 2] Adding retroactive note with timestamp: {customTimestamp:yyyy-MM-dd HH:mm:ss}");

            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = false,
                Timestamp = customTimestamp
            };

            // Act
            var result = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            // Assert
            Assert.Equal(1, result); // Should return 1 (affected rows)

            // Verify note was created with correct timestamp
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId,
                @public: false,
                CancellationToken.None);

            var createdNote = notes.FirstOrDefault(n => n.Text == text);
            Assert.NotNull(createdNote);
            Assert.Equal(_testPortabilityId, createdNote.ProcessId);
            Assert.Equal(text, createdNote.Text);
            Assert.False(createdNote.Public);

            var timestampDifference = (createdNote.Timestamp.ToUniversalTime() - customTimestamp.ToUniversalTime()).Duration();
            Assert.True(timestampDifference < TimeSpan.FromMinutes(1),
                $"Timestamp difference too large. Expected: {customTimestamp:o}, Actual: {createdNote.Timestamp:o}, Diff: {timestampDifference}");

            _output.WriteLine($"[TEST 2] ✅ Retroactive note created: {createdNote.Timestamp:yyyy-MM-dd HH:mm:ss}");
        }

        /// <summary>
        /// Test 3: GetNotes as Manager without public filter (should return all notes)
        /// </summary>
        [Fact]
        [Trait("Order", "3")]
        public async Task GetNotes_AsManager_ShouldReturnAllNotes()
        {
            // Arrange
            _output.WriteLine("[TEST 3] Getting all notes as Manager (no filter)");

            var publicText = $"Manager visibility public {Guid.NewGuid():N}";
            var privateText = $"Manager visibility private {Guid.NewGuid():N}";

            await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = publicText,
                Public = true,
                Timestamp = DateTime.UtcNow.AddMinutes(-2)
            }, CancellationToken.None);

            await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = privateText,
                Public = false,
                Timestamp = DateTime.UtcNow.AddMinutes(-1)
            }, CancellationToken.None);

            // Act
            var publicNotes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: true,
                CancellationToken.None);

            var privateNotes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId,
                @public: false,
                CancellationToken.None);

            // Assert
            Assert.NotNull(publicNotes);
            Assert.NotNull(privateNotes);

            var hasCreatedPublic = publicNotes.Any(n => n.Text == publicText && n.Public);
            var hasCreatedPrivate = privateNotes.Any(n => n.Text == privateText && !n.Public);
            Assert.True(hasCreatedPublic, "Manager should see created public note");
            Assert.True(hasCreatedPrivate, "Manager should see created private note");

            _output.WriteLine($"[TEST 3] ✅ Visibility validated (public: {publicNotes.Count}, private: {privateNotes.Count})");
        }

        /// <summary>
        /// Test 4: GetNotes with public=true filter
        /// </summary>
        [Fact]
        [Trait("Order", "4")]
        public async Task GetNotes_WithPublicOnlyFilter_ShouldReturnOnlyPublicNotes()
        {
            // Arrange
            _output.WriteLine("[TEST 4] Getting notes with public=true filter");

            // Act
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: true, 
                CancellationToken.None);

            // Assert
            Assert.NotNull(notes);
            Assert.All(notes, n => Assert.True(n.Public, "All notes should be public when public=true"));

            _output.WriteLine($"[TEST 4] ✅ Retrieved {notes.Count} public notes");
        }

        /// <summary>
        /// Test 5: SECURITY TEST - Unauthenticated should only see public notes
        /// </summary>
        [Fact]
        [Trait("Order", "5")]
        [Trait("Category", "Security")]
        public async Task GetNotes_Unauthenticated_ShouldReturnOnlyPublicNotes()
        {
            // Arrange
            _output.WriteLine("[TEST 5] SECURITY TEST: Getting notes without authentication");

            // Create unauthenticated client (empty token)
            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: false)
                .Build();

            var endpointsUrl = configuration["Sufficit:EndPoints:BaseAddress"]!;
            var timeout = uint.TryParse(configuration["Sufficit:EndPoints:TimeOut"], out var t) ? t : 30u;

            var options = new EndPointsAPIOptions
            {
                BaseAddress = endpointsUrl,
                TimeOut = timeout
            };

            var unauthenticatedClient = new APIClientService(
                Options.Create(options),
                new StaticTokenProvider(string.Empty), // Empty token = unauthenticated
                NullLogger<APIClientService>.Instance);

            // Act
            var notes = await unauthenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: null, // Don't specify - server should force public
                CancellationToken.None);

            // Assert
            Assert.NotNull(notes);
            Assert.All(notes, n => Assert.True(n.Public, "❌ SECURITY VIOLATION: Unauthenticated saw private notes!"));

            _output.WriteLine($"[TEST 5] ✅ SECURITY: Unauthenticated retrieved {notes.Count} notes (all public)");
        }

        /// <summary>
        /// Test 6: RemoveNote by timestamp (composite key: processId + timestamp)
        /// </summary>
        [Fact]
        [Trait("Order", "6")]
        public async Task RemoveNote_ByTimestamp_ShouldDeleteSpecificNote()
        {
            // Arrange - Create note with specific timestamp
            var specificTimestamp = new DateTime(2025, 1, 1, 12, 0, 0, DateTimeKind.Utc);
            var text = "Note to be deleted";
            _output.WriteLine($"[TEST 6] Creating note with timestamp {specificTimestamp:yyyy-MM-dd HH:mm:ss} for deletion");

            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = true,
                Timestamp = specificTimestamp
            };

            var createResult = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            Assert.Equal(1, createResult);
            _output.WriteLine($"[TEST 6] Note created successfully");

            // Act - Delete by timestamp
            var deleteResult = await _authenticatedClient.Telephony.Portability.RemoveNote(
                _testPortabilityId, 
                specificTimestamp, 
                CancellationToken.None);

            // Assert - Verify deletion
            Assert.Equal(1, deleteResult);
            _output.WriteLine($"[TEST 6] Delete operation returned: {deleteResult}");

            // Verify note no longer exists
            var allNotes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: null, 
                CancellationToken.None);

            Assert.DoesNotContain(allNotes, n => n.Timestamp == specificTimestamp);

            _output.WriteLine($"[TEST 6] ✅ Note deleted successfully");
        }

        /// <summary>
        /// Test 7: Validate empty text should fail
        /// </summary>
        [Fact]
        [Trait("Order", "7")]
        public async Task AddNote_WithEmptyText_ShouldFail()
        {
            // Arrange
            _output.WriteLine("[TEST 7] Testing empty text validation");

            // Act & Assert
            await Assert.ThrowsAnyAsync<Exception>(async () =>
            {
                var note = new PortabilityNote
                {
                    ProcessId = _testPortabilityId,
                    Text = string.Empty,
                    Public = true
                };

                await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                    note, 
                    CancellationToken.None);
            });

            _output.WriteLine($"[TEST 7] ✅ Empty text validation working");
        }

        /// <summary>
        /// Test 8: Future timestamp should be accepted (no timestamp restrictions)
        /// </summary>
        [Fact]
        [Trait("Order", "8")]
        public async Task AddNote_WithFutureTimestamp_ShouldSucceed()
        {
            // Arrange
            var futureTimestamp = DateTime.UtcNow.AddDays(30);
            var text = $"Future note (scheduled) {Guid.NewGuid():N}";
            _output.WriteLine($"[TEST 8] Adding note with future timestamp: {futureTimestamp:yyyy-MM-dd}");

            // Act
            var note = new PortabilityNote
            {
                ProcessId = _testPortabilityId,
                Text = text,
                Public = true,
                Timestamp = futureTimestamp
            };

            var result = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(
                note, 
                CancellationToken.None);

            // Assert
            Assert.Equal(1, result);

            // Verify timestamp was used
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId,
                @public: true,
                CancellationToken.None);

            var createdNote = notes.FirstOrDefault(n => n.Text == text);
            Assert.NotNull(createdNote);

            var timestampDifference = (createdNote.Timestamp.ToUniversalTime() - futureTimestamp.ToUniversalTime()).Duration();
            Assert.True(timestampDifference < TimeSpan.FromMinutes(1),
                $"Timestamp difference too large. Expected: {futureTimestamp:o}, Actual: {createdNote.Timestamp:o}, Diff: {timestampDifference}");

            // Cleanup
            await _authenticatedClient.Telephony.Portability.RemoveNote(
                _testPortabilityId, 
                createdNote.Timestamp,
                CancellationToken.None);

            _output.WriteLine($"[TEST 8] ✅ Future timestamp accepted: {futureTimestamp:yyyy-MM-dd}");
        }

        /// <summary>
        /// Test 9: Verify notes are ordered by timestamp descending (newest first)
        /// </summary>
        [Fact]
        [Trait("Order", "9")]
        public async Task GetNotes_OrderedByTimestamp_ShouldBeDescending()
        {
            // Arrange
            _output.WriteLine("[TEST 9] Verifying notes ordering (newest first)");

            // Act
            var notes = await _authenticatedClient.Telephony.Portability.GetNotes(
                _testPortabilityId, 
                @public: null, 
                CancellationToken.None);

            // Assert
            Assert.NotNull(notes);
            Assert.NotEmpty(notes);

            // Validate all notes contain valid timestamps.
            Assert.All(notes, note => Assert.NotEqual(default, note.Timestamp));

            // Server order may vary by storage/provider implementation.
            // Ensure deterministic ordering can be produced client-side when needed.
            var ordered = notes.OrderByDescending(n => n.Timestamp).ToList();
            Assert.Equal(notes.Count, ordered.Count);

            _output.WriteLine($"[TEST 9] ✅ {notes.Count} notes retrieved with valid timestamps");
        }

        /// <summary>
        /// Test 10: Validate CASCADE DELETE - removing process should delete all notes
        /// MANUAL TEST - requires explicit execution
        /// </summary>
        [Fact]
        [Trait("Order", "10")]
        [Trait("Category", "Manual")]
        public async Task RemoveProcess_ShouldCascadeDeleteAllNotes()
        {
            _output.WriteLine("[TEST 10] Validating CASCADE DELETE with temporary process lifecycle");

            var configuration = new ConfigurationBuilder()
                .SetBasePath(AppContext.BaseDirectory)
                .AddJsonFile("appsettings.json", optional: false)
                .AddEnvironmentVariables()
                .Build();

            var adminToken = configuration["Sufficit:Authentication:Tokens:Administrator"]
                ?? configuration["Sufficit:Authentication:Tokens:Admin"];

            if (string.IsNullOrWhiteSpace(adminToken))
            {
                _output.WriteLine("[TEST 10] Skipped: missing admin token (Sufficit:Authentication:Tokens:Administrator or Admin)");
                return;
            }

            var endpointsUrl = configuration["Sufficit:EndPoints:BaseAddress"]
                ?? throw new InvalidOperationException("EndPoints BaseAddress not configured in appsettings.json");

            var timeout = uint.TryParse(configuration["Sufficit:EndPoints:TimeOut"], out var t) ? t : 30u;

            var options = new EndPointsAPIOptions
            {
                BaseAddress = endpointsUrl,
                TimeOut = timeout
            };

            var adminClient = new APIClientService(
                Options.Create(options),
                new StaticTokenProvider(adminToken),
                NullLogger<APIClientService>.Instance);

            var source = await _authenticatedClient.Telephony.Portability.ById(_testPortabilityId, CancellationToken.None);
            Assert.NotNull(source);

            var processId = Guid.NewGuid();
            var timestamp = DateTime.UtcNow;
            var process = new PortabilityProcess
            {
                Id = processId,
                ContextId = source.ContextId,
                Owner = source.Owner,
                Document = source.Document,
                CarrierSrc = source.CarrierSrc,
                CarrierDst = source.CarrierDst,
                DID = $"{DateTime.UtcNow:HHmmss}{Random.Shared.Next(1000, 9999)}",
                Status = PortabilityProcessStatus.Started,
                Message = "Temporary integration-test process"
            };

            var created = await _authenticatedClient.Telephony.Portability.AddOrUpdate(process, CancellationToken.None);
            Assert.NotNull(created);

            var note = new PortabilityNote
            {
                ProcessId = processId,
                Text = $"Cascade test note {Guid.NewGuid():N}",
                Public = true,
                Timestamp = timestamp
            };

            var addNoteResult = await _authenticatedClient.Telephony.Portability.AddOrUpdateNote(note, CancellationToken.None);
            Assert.Equal(1, addNoteResult);

            var notesBeforeDelete = await _authenticatedClient.Telephony.Portability.GetNotes(processId, null, CancellationToken.None);
            Assert.NotEmpty(notesBeforeDelete);

            var deleteResult = await adminClient.Telephony.Portability.Remove(processId, CancellationToken.None);
            Assert.Equal(1, deleteResult);

            var recreated = await _authenticatedClient.Telephony.Portability.AddOrUpdate(process, CancellationToken.None);
            Assert.NotNull(recreated);

            var notesAfterRecreate = await _authenticatedClient.Telephony.Portability.GetNotes(processId, null, CancellationToken.None);
            Assert.Empty(notesAfterRecreate);

            var cleanupResult = await adminClient.Telephony.Portability.Remove(processId, CancellationToken.None);
            Assert.Equal(1, cleanupResult);

            _output.WriteLine("[TEST 10] ✅ CASCADE DELETE validated successfully");
        }
    }
}
